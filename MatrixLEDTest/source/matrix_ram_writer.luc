module matrix_ram_writer #(
  // 32 by 64 LED matrix by default, separated into top-16 rows and bottom 16-rows
  // both halves row i are written together for all rows 0 to 15 in a rapid loop 
  ADDRESS_SIZE = 4 : ADDRESS_SIZE > 0, //width of the address field (ABCD signals for matrix_led) 
  MATRIX_WIDTH = 64 : MATRIX_WIDTH > 0, //number of LEDs per row in the matrix
  DATA_WIDTH = 16 : DATA_WIDTH > 0  
  )(
    input clk,  // clock
    input rst,  // reset
    input reload,
    input new_data[DATA_WIDTH],
    
    output row_address_top[ADDRESS_SIZE],
    output col_address_top[$clog2(MATRIX_WIDTH)],
    output we_top,
    output wd_top[3],
    
    output row_address_btm[ADDRESS_SIZE],
    output col_address_btm[$clog2(MATRIX_WIDTH)],
    output we_btm,
    output wd_btm[3],
    
    output ready
  ) {
  
    fsm writer_state(.clk(clk), .rst(rst)) = {START, LOAD_ADDRESS, LOAD_WAIT, LOOP};
 
    const START_DATA = 16b0111111111111111; // some random triangle 
  
    // replace this with row-col mapping to form better-looking shapes
    const MAPPING = {
        {6d0, 6d0}, //unused
        {6d9, 6d14},
        {6d9, 6d12},
        {6d9, 6d10},
        {6d9, 6d8},
        {6d9, 6d6},
        {6d8, 6d13},
        {6d8, 6d11},
        {6d8, 6d9},
        {6d8, 6d7},
        {6d7, 6d12},
        {6d7, 6d10},
        {6d7, 6d8},
        {6d6, 6d11},
        {6d6, 6d9},
        {6d5, 6d10}
    };
  
    dff bitloader[$clog2(DATA_WIDTH)](#INIT(0), .clk(clk), .rst(rst));
    dff data[DATA_WIDTH](#INIT(0), .clk(clk), .rst(rst));

  
    dff data_col_address[$clog2(MATRIX_WIDTH)](#INIT(0),.clk(clk),.rst(rst));
    dff data_row_address[ADDRESS_SIZE](#INIT(0),.clk(clk),.rst(rst));
  
    // to write to all 3-bit cells in top_ram and bottom_ram 
    // for 64 by 32 matrix, there are 64 by 16 cells in each ram, each cell contains 3 bit, so ram_writer_address is 10 bit long
    dff ram_writer_address[$clog2(MATRIX_WIDTH*$pow(ADDRESS_SIZE, 2))](#INIT(0), .clk(clk), .rst(rst));
  
   

  always {
    ready = b0;
    we_top = b0;
    we_btm = b0;
    row_address_top = 0;
    row_address_btm = 0;
    col_address_top = 0;
    col_address_btm = 0;
    wd_top = 0;
    wd_btm = 0;
    
 
    
    case(writer_state.q){
      writer_state.START:
        data.d = START_DATA;
        writer_state.d = writer_state.LOAD_ADDRESS;
        
      writer_state.LOAD_ADDRESS:
        row_address_top = MAPPING[bitloader.q][1];
        col_address_top = MAPPING[bitloader.q][0];
          
        row_address_btm = data_row_address.q;
        col_address_btm = data_col_address.q;
        wd_top = b000;
        if (data.q[bitloader.q] == 1){
            wd_top = b001;
        }
  
        wd_btm = b100;
        we_top = b1;
        we_btm = b1;
        writer_state.d = writer_state.LOAD_WAIT;
        if (&bitloader.q == 1){
            bitloader.d = 0;
            writer_state.d = writer_state.LOOP;
        }
      
      writer_state.LOAD_WAIT:
        //advance write address by 1
        bitloader.d = bitloader.q + 1;
        data_col_address.d = data_col_address.q + 1;
        writer_state.d = writer_state.LOAD_ADDRESS;
     
      writer_state.LOOP:
        //provide output from ram after writing is done
        ready = 1;
        writer_state.d = writer_state.LOOP;
        if (reload){
           data.d = new_data;
           writer_state.d = writer_state.LOAD_ADDRESS;
        }
  }
      
 
  }
}
